selected_regressors = selected,
model = best_model,
BIC = best_BIC
))
}
resultado_forward <- forward_sarimax_safe(y_train, X_train, lambda_bc)
resultado_forward$selected_regressors
summary(resultado_forward$model)
fit <- resultado_forward$model
## DaignÃ³stico
res <- fit$residuals
hist(res)
skewness(res)
kurtosis(res)
# Test
shapiro.test(res)
fit_t <- fitdistr(res, densfun = "t")
nu    <- fit_t$estimate["df"]
mu    <- fit_t$estimate["m"]
sigma <- fit_t$estimate["s"]
res_std <- (res - mu) / sigma
ks.test(res_std, "pt", df = nu)
LSTS::Box.Ljung.Test(res, lag=60)
acf(res,  lag.max=60)
acf(res^2,lag.max=60)
h <- length(y_test)
selected <- resultado_forward$selected_regressors
xreg_forecast <- as.matrix(X_test[, selected, drop = FALSE])
fc <- forecast(fit, xreg = xreg_forecast, h = h)
accuracy(fc, y_test)
fc
pred_full <- as.numeric(fc$mean)
y_test_vec <- as.numeric(y_test)
length(pred_full)
length(y_test_vec)
accuracy(pred_full, y_test_vec)
pred <- as.numeric(fc$mean)
lo80 <- as.numeric(fc$lower[,1])
hi80 <- as.numeric(fc$upper[,1])
lo95 <- as.numeric(fc$lower[,2])
hi95 <- as.numeric(fc$upper[,2])
tt <- 1:length(y_test)
yr <- range(c(y_test, lo95, hi95), na.rm = TRUE)
par(bty = "n")
plot(tt, y_test, type = "l", ylim = yr,
xlab = "Tiempo (Ã­ndice en test)", ylab = "PM2.5",
main = "ValidaciÃ³n SARIMA")
polygon(
c(tt, rev(tt)),
c(hi95, rev(lo95)),
col = rgb(0, 0, 1, 0.15), border = NA
)
polygon(
c(tt, rev(tt)),
c(hi80, rev(lo80)),
col = rgb(0, 0, 1, 0.30), border = NA
)
lines(tt, y_test, col = "black")
lines(tt, pred,  col = "red")
legend(
"topright",
legend = c("PredicciÃ³n", "IC 80%", "IC 95%"),
col    = c("red", rgb(0,0,1,0.30), rgb(0,0,1,0.15)),
lwd    = c(2,10,10),
bty    = "n"
)
summary(resultado_forward$model)
coefs <- coef(fit)
ses   <- sqrt(diag(fit$var.coef))
tvals <- abs(coefs / ses)
tvals
fixed_vec <- rep(NA, length(coef(fit)))
names(fixed_vec) <- names(coef(fit))
fixed_vec["valor_NO2"] <- 0
fixed_vec <- rep(NA, length(coef(fit)))
names(fixed_vec) <- names(coef(fit))
fixed_vec["valor_NO2"] <- 0
fit <-  Arima(
y_train,
order    = c(3,1,1),
xreg     = x_train,
lambda   = lambda,
biasadj  = TRUE,
fixed    = fixed_vec
)
fit <-  Arima(
y_train,
order    = c(3,1,1),
xreg     = X_train,
lambda   = lambda,
biasadj  = TRUE,
fixed    = fixed_vec
)
selected <- resultado_forward$selected_regressors
xreg <- as.matrix(X_test[, selected, drop = FALSE])
fit <-  Arima(
y_train,
order    = c(3,1,1),
xreg     = xreg,
lambda   = lambda,
biasadj  = TRUE,
fixed    = fixed_vec
)
selected <- resultado_forward$selected_regressors
xreg <- as.matrix(X_train[, selected, drop = FALSE])
fit <-  Arima(
y_train,
order    = c(3,1,1),
xreg     = xreg,
lambda   = lambda,
biasadj  = TRUE,
fixed    = fixed_vec
)
summary(fit)
coefs <- coef(fit)
ses   <- sqrt(diag(fit$var.coef))
tvals <- abs(coefs / ses)
tvals
## DaignÃ³stico
res <- fit$residuals
hist(res)
skewness(res)
kurtosis(res)
# Test
shapiro.test(res)
fit_t <- fitdistr(res, densfun = "t")
nu    <- fit_t$estimate["df"]
mu    <- fit_t$estimate["m"]
sigma <- fit_t$estimate["s"]
res_std <- (res - mu) / sigma
ks.test(res_std, "pt", df = nu)
LSTS::Box.Ljung.Test(res, lag=60)
acf(res,  lag.max=60)
acf(res^2,lag.max=60)
h <- length(y_test)
selected <- resultado_forward$selected_regressors
xreg_forecast <- as.matrix(X_test[, selected, drop = FALSE])
fc <- forecast(fit, xreg = xreg_forecast, h = h)
pred_full <- as.numeric(fc$mean)
y_test_vec <- as.numeric(y_test)
accuracy(pred_full, y_test_vec)
pred <- as.numeric(fc$mean)
lo80 <- as.numeric(fc$lower[,1])
hi80 <- as.numeric(fc$upper[,1])
lo95 <- as.numeric(fc$lower[,2])
hi95 <- as.numeric(fc$upper[,2])
tt <- 1:length(y_test)
yr <- range(c(y_test, lo95, hi95), na.rm = TRUE)
par(bty = "n")
plot(tt, y_test, type = "l", ylim = yr,
xlab = "Tiempo (Ã­ndice en test)", ylab = "PM2.5",
main = "ValidaciÃ³n SARIMA")
polygon(
c(tt, rev(tt)),
c(hi95, rev(lo95)),
col = rgb(0, 0, 1, 0.15), border = NA
)
polygon(
c(tt, rev(tt)),
c(hi80, rev(lo80)),
col = rgb(0, 0, 1, 0.30), border = NA
)
lines(tt, y_test, col = "black")
lines(tt, pred,  col = "red")
legend(
"topright",
legend = c("PredicciÃ³n", "IC 80%", "IC 95%"),
col    = c("red", rgb(0,0,1,0.30), rgb(0,0,1,0.15)),
lwd    = c(2,10,10),
bty    = "n"
)
fixed_vec <- rep(NA, length(coef(fit)))
names(fixed_vec) <- names(coef(fit))
fixed_vec["valor_NO2"] <- 0
fixed_vec["valor_NOX"] <- 0
selected <- resultado_forward$selected_regressors
xreg <- as.matrix(X_train[, selected, drop = FALSE])
fit <-  Arima(
y_train,
order    = c(3,1,1),
xreg     = xreg,
lambda   = lambda,
biasadj  = TRUE,
fixed    = fixed_vec
)
summary(fit)
coefs <- coef(fit)
ses   <- sqrt(diag(fit$var.coef))
tvals <- abs(coefs / ses)
tvals
## DaignÃ³stico
res <- fit$residuals
hist(res)
skewness(res)
kurtosis(res)
# Test
shapiro.test(res)
fit_t <- fitdistr(res, densfun = "t")
nu    <- fit_t$estimate["df"]
mu    <- fit_t$estimate["m"]
sigma <- fit_t$estimate["s"]
res_std <- (res - mu) / sigma
ks.test(res_std, "pt", df = nu)
LSTS::Box.Ljung.Test(res, lag=60)
acf(res,  lag.max=60)
acf(res^2,lag.max=60)
h <- length(y_test)
selected <- resultado_forward$selected_regressors
xreg_forecast <- as.matrix(X_test[, selected, drop = FALSE])
fc <- forecast(fit, xreg = xreg_forecast, h = h)
pred_full <- as.numeric(fc$mean)
y_test_vec <- as.numeric(y_test)
accuracy(pred_full, y_test_vec)
pred <- as.numeric(fc$mean)
lo80 <- as.numeric(fc$lower[,1])
hi80 <- as.numeric(fc$upper[,1])
lo95 <- as.numeric(fc$lower[,2])
hi95 <- as.numeric(fc$upper[,2])
tt <- 1:length(y_test)
yr <- range(c(y_test, lo95, hi95), na.rm = TRUE)
par(bty = "n")
plot(tt, y_test, type = "l", ylim = yr,
xlab = "Tiempo (Ã­ndice en test)", ylab = "PM2.5",
main = "ValidaciÃ³n SARIMA")
polygon(
c(tt, rev(tt)),
c(hi95, rev(lo95)),
col = rgb(0, 0, 1, 0.15), border = NA
)
polygon(
c(tt, rev(tt)),
c(hi80, rev(lo80)),
col = rgb(0, 0, 1, 0.30), border = NA
)
lines(tt, y_test, col = "black")
lines(tt, pred,  col = "red")
legend(
"topright",
legend = c("PredicciÃ³n", "IC 80%", "IC 95%"),
col    = c("red", rgb(0,0,1,0.30), rgb(0,0,1,0.15)),
lwd    = c(2,10,10),
bty    = "n"
)
colnames(num_data)
factorial(8)
2^8
###################################
##      Proyecto - EYP3907       ##
## Vicente Garay - MatÃ­as Pineda ##
###################################
library(readr)
library(dplyr)
library(lubridate)
library(forecast)
library(LSTS)
library(MASS)
library(purrr)
library(car)
library(moments)
library(imputeTS)
## Data SINCA EstacÃ­on Quintero
# --- PM25 ---
PM25 <- read_delim(
"DATA/PM25.csv",
delim = ";",
trim_ws = TRUE,
col_types = cols(.default = "c"),
show_col_types = FALSE
)
PM25 <- PM25 %>%
mutate(
fecha = ymd(sprintf("20%06s", `FECHA (YYMMDD)`)),
val_valid = as.numeric(gsub(",", ".", `Registros validados`)),
val_pre   = as.numeric(gsub(",", ".", `Registros preliminares`)),
val_no    = as.numeric(gsub(",", ".", `Registros no validados`)),
valor_PM25     = coalesce(val_valid, val_pre, val_no)
) %>%
dplyr::select(fecha, valor_PM25)
summary(PM25)
na_vec <- is.na(PM25$valor_PM25)
rle_na <- rle(na_vec)
rle_na$lengths[rle_na$values == TRUE]
which(na_vec)
## --- Limpiar PM2.5, imputar y JUNTAR TODO ---
# Imputar NA puntuales restantes
PM25$imputado_pm <- is.na(PM25$valor_PM25)
PM25 <- PM25 %>%
mutate(
valor_PM25 = na_kalman(valor_PM25, model = "auto.arima")
)
par(bty="n")
plot(
PM25$fecha, PM25$valor_PM25, type = "l",
main = "PM2.5 imputado",
xlab = "Tiempo",
ylab = expression("Material particulado 2.5 ( "*mu*"g/m"^3*")")
)
points(x = PM25$fecha[PM25$imputado_pm],
y = PM25$valor_PM25[PM25$imputado_pm],
col = "red", pch = 19, cex = 0.5)
legend("topleft",
legend = c("Valor imputado"),
col = "red",
pch = 19,
bty = "n")
start_year  <- as.numeric(format(min(PM25$fecha, na.rm = TRUE), "%Y"))
start_day   <- as.numeric(format(min(PM25$fecha, na.rm = TRUE), "%j"))
start_ts <- c(start_year, start_day)
PM25_vec <- PM25$valor_PM25
## Periodograma
LSTS::periodogram(PM25_vec)
per <- LSTS::periodogram(PM25_vec, plot = FALSE)
I_lambda <- per$periodogram
lambda   <- per$lambda
ord <- order(I_lambda, decreasing = TRUE)
lambda_top <- lambda[ord[1:10]]
s_top     <- 2*pi / lambda_top
cbind(lambda_top, s_top)
## Pasar a ts
PM25_ts <- ts(PM25_vec, frequency = 14, start = start_ts)
## separaciÃ³n 90/10
n       <- length(PM25_ts)
n_train <- floor(0.9 * n)
y_train <- window(PM25_ts, end = start(PM25_ts) + c(0, n_train - 1))
y_test  <- window(PM25_ts, start = start(PM25_ts) + c(0, n_train))
## Box Cox
lambda_bc <- BoxCox.lambda(y_train)
lambda_bc
MASS::boxcox(y_train~1)
## ACF y PACF
acf(y_train, lag.max = 600, main = "ACF PM2.5")
pacf(y_train, lag.max = 600, main = "PACF PM2.5")
# Ajuste SARIMA
fit <- auto.arima(
y_train,
seasonal   = TRUE,
lambda = lambda_bc,
biasadj = TRUE
)
summary(fit)
coefs <- coef(fit)
ses   <- sqrt(diag(fit$var.coef))
tvals <- abs(coefs / ses)
tvals
fit_adj <- Arima(
y_train,
order = c(2,1,3),
seasonal = c(0,0,1),
lambda = lambda_bc,
biasadj = TRUE
)
summary(fit_adj)
# Ajuste SARIMAX
bruteforce_sarimax <- function(y_train, X_train, order, seasonal=NULL, lambda=NULL) {
# Convertir X a matriz
X <- as.matrix(X_train)
p <- ncol(X)
# Todas las combinaciones posibles: 0..255
combos <- lapply(0:(2^p - 1), function(mask){
# obtener Ã­ndices de regresores "encendidos"
which(as.logical(intToBits(mask)[1:p]))
})
results <- vector("list", length(combos))
for(i in seq_along(combos)){
idx <- combos[[i]]
xreg <- if(length(idx) == 0) NULL else X[, idx, drop = FALSE]
formula <- paste0("Regresores: {",
if(length(idx)==0) "ninguno" else paste0(colnames(X)[idx], collapse=", "),
"}")
# Ajuste SARIMA/SARIMAX
fit <- tryCatch({
Arima(
y_train,
order    = order,
seasonal = seasonal,
xreg     = xreg,
lambda   = lambda,
method   = "ML"
)
}, error = function(e) NULL)
if(is.null(fit)){
results[[i]] <- list(
comb_id   = i,
k_regs    = length(idx),
regs      = paste(idx, collapse=","),
AIC       = Inf,
BIC       = Inf,
loglik    = NA,
converged = FALSE
)
} else {
results[[i]] <- list(
comb_id   = i,
k_regs    = length(idx),
regs      = paste(idx, collapse=","),
AIC       = AIC(fit),
BIC       = BIC(fit),
loglik    = as.numeric(logLik(fit)),
converged = TRUE,
model     = fit
)
}
}
# Convertir a tabla ordenada por BIC
df <- bind_rows(results) %>% arrange(BIC)
list(
table  = df,
models = results
)
}
res_brute <- bruteforce_sarimax(
y_train = y_train,
X_train = X_train,
order   = c(2,1,3),
seasonal = c(0,0,1),
lambda  = -0.1149271
)
# Ajuste SARIMAX
bruteforce_sarimax <- function(
y_train, X_train, order, seasonal=NULL, lambda=NULL, verbose=FALSE
) {
# Convertir X a matriz
X <- as.matrix(X_train)
p <- ncol(X)
# Todas las combinaciones posibles: 0..255
combos <- lapply(0:(2^p - 1), function(mask){
which(as.logical(intToBits(mask)[1:p]))
})
results <- vector("list", length(combos))
n_models <- length(combos)
for(i in seq_along(combos)){
idx <- combos[[i]]
xreg <- if(length(idx) == 0) NULL else X[, idx, drop = FALSE]
reg_names <- if(length(idx)==0) {
"ninguno"
} else {
paste0(colnames(X)[idx], collapse=", ")
}
if (verbose) {
cat("\n==========================================================\n")
cat(sprintf("ðŸ“Œ Modelo %d / %d\n", i, n_models))
cat(sprintf("   Regresores: %s\n", reg_names))
cat("==========================================================\n")
}
# Ajuste SARIMA/SARIMAX
fit <- tryCatch({
Arima(
y_train,
order    = order,
seasonal = seasonal,
xreg     = xreg,
lambda   = lambda,
biasadj = TRUE
)
}, error = function(e){
if(verbose){
cat("âŒ Error al ajustar modelo:", e$message, "\n")
}
NULL
})
if(is.null(fit)){
# Guardar fallo
results[[i]] <- list(
comb_id   = i,
k_regs    = length(idx),
regs      = paste(idx, collapse=","),
AIC       = Inf,
BIC       = Inf,
loglik    = NA,
converged = FALSE
)
} else {
# Guardar modelo OK
results[[i]] <- list(
comb_id   = i,
k_regs    = length(idx),
regs      = paste(idx, collapse=","),
AIC       = AIC(fit),
BIC       = BIC(fit),
loglik    = as.numeric(logLik(fit)),
converged = TRUE,
model     = fit
)
# Mostrar summary
if(verbose){
cat("\nðŸ“„ Summary del modelo ajustado:\n")
print(summary(fit))
}
}
}
# Convertir a tabla ordenada por BIC
df <- dplyr::bind_rows(results) %>% dplyr::arrange(BIC)
list(
table  = df,
models = results
)
}
res_brute <- bruteforce_sarimax(
y_train = y_train,
X_train = X_train,
order   = c(2,1,3),
seasonal = c(0,0,1),
lambda  = -0.1149271 ,
verbose = TRUE
)
head(res_brute$table, 5)
plot(tail(y_train, N))
plot(tail(y_train, h))
plot(tail(boxcox(y_train), h))
plot(tail(BoxCox(y_train, -0.1149271), h))
tail(datos)
tail(datos, 1)
